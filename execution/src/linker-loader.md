# Linker
In computing, a linker or link editor is a computer utility program that takes one or more object files generated by a compiler and combines them into a single executable file, library file, or another 'object' file.

## Dynamic Linking
Many operating system environments allow dynamic linking, __deferring the resolution of some undefined symbols until a program is run.__ That means that the executable code still contains undefined symbols, plus a list of objects or libraries that will provide definitions for these. Loading the program will load these objects/libraries as well, and perform a final linking.

## Static Linking
Static linking is __the result of the linker copying all library routines used in the program into the executable image.__ This may require more disk space and memory than dynamic linking, but is more portable, since it does not require the presence of the library on the system where it runs. Static linking also prevents "DLL Hell", since each program includes exactly the versions of library routines that it requires, with no conflict with other programs. A program using just a few routines from a library does not require the entire library to be installed.

## Relocation
As the compiler has no information on the layout of objects in the final output, it cannot take advantage of shorter or more efficient instructions that __place a requirement on the address of another object__. For example, a jump instruction can reference an absolute address or an offset from the current location, and the offset could be expressed with different lengths depending on the distance to the target. By generating the most conservative instruction (usually the largest relative or absolute variant, depending on platform) and adding relaxation hints, it is possible to substitute shorter or more efficient instructions during the final link. This step can be performed only after all input objects have been read and assigned temporary addresses; the linker relaxation pass subsequently reassigns addresses, which may in turn allow more relaxations to occur. In general, the substituted sequences are shorter, which allows this process to always converge on the best solution given a fixed order of objects; if this is not the case, relaxations can conflict, and the linker needs to weigh the advantages of either option.

## Linkage Editor
In IBM System/360 mainframe environments such as OS/360, including z/OS for the z/Architecture mainframes, this type of program is known as a linkage editor. As the name implies a linkage editor __has the additional capability of allowing the addition, replacement, and/or deletion of individual program sections.__ Operating systems such as OS/360 have format for executable load-modules containing supplementary data about the component sections of a program, so that an individual program section can be replaced, and other parts of the program updated so that relocatable addresses and other references can be corrected by the linkage editor, as part of the process.

# Loader
In computer systems a loader is __the part of an operating system that is responsible for loading programs and libraries.__ It is one of the essential stages in the process of starting a program, as it places programs into memory and prepares them for execution. Loading a program involves reading the contents of the executable file containing the program instructions into memory, and then carrying out other required preparatory tasks to prepare the executable for running. Once loading is complete, the operating system starts the program by passing control to the loaded program code.

## Responsibilities
In Unix, the loader is __the handler for the system call execve().__ The Unix loader's tasks include:
+ validation (permissions, memory requirements etc.);
+ copying the program image from the disk into main memory;
+ copying the command-line arguments on the stack;
+ initializing registers (e.g., the stack pointer);
+ jumping to the program entry point (_start).

In Microsoft Windows 7 and above, the loader is __the LdrInitializeThunk function contained in ntdll.dll,__ that does the following:
+ initialisation of structures in the DLL itself (i.e. critical sections, module lists);
+ validation of executable to load;
+ creation of a heap (via the function RtlCreateHeap);
+ allocation of environment variable block and PATH block;
+ addition of executable and NTDLL to the module list (a doubly-linked list);
+ loading of KERNEL32.DLL to obtain several important functions, for instance BaseThreadInitThunk;
+ loading of executable's imports (i.e. dynamic-link libraries) recursively (check the imports' imports, their imports and so on);
+ in debug mode, raising of system breakpoint;
+ initialisation of DLLs;
+ garbage collection;
+ calling NtContinue on the context parameter given to the loader function (i.e. jumping to RtlUserThreadStart, that will start the executable)

## Relocating loaders
Some operating systems need relocating loaders, ___which adjust addresses (pointers) in the executable to compensate for variations in the address at which loading starts.__ The operating systems that need relocating loaders are those in which a program is not always loaded into the same location in the address space and in which pointers are absolute addresses rather than offsets from the program's base address. Some well-known examples are IBM's OS/360 for their System/360 mainframes, and its descendants, including z/OS for the z/Architecture mainframes.

## OS/360 & Derivatives
In OS/360 and descendant systems, the (privileged) operating system facility is called IEWFETCH, and is __an internal component of the OS Supervisor,__ whereas the (non-privileged) LOADER application can perform many of the same functions, plus those of the Linkage Editor, and is entirely external to the OS Supervisor (although it certainly uses many Supervisor services).
